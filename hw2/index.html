<html>
	<head>
		Homework 2 Writeup
	</head>
	<body>
		<a href="https://cal-cs184-student.github.io/hw-webpages-sp24-ericlu28/hw2/index.html">Webpage Link</a>
		<h1>Homework 2 Writeup</h1>
			<h2>Overview: </h2>
				<p>

				</p>
			<h2>Section 1 Part 1:</h2>
				<h3>Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.</h3>
					<p>
						De Casteljau's algorithm is a recursive algorithm meant to evaluate Bezier curves. It takes as input an initial
						set of control points and a parameter t that decides how to interpolate along the control points.  In the first 
						iteration, the algorithm calculates intermediate points along the edges between the control points (distance
						based on t), then connects these 2 intermediate points. We use the newly created polygon as the next points
						to recurse on. This process repeats until the algorithm has reached a single point or if the curve is smooth.
					</p>
				<h3>Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. 
					Use this Bezier curve for your screenshots below.</h3>
					<p>
						TODO:
					</p>
				<h3>Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated
					 point. Press E to step through. Toggle C to show the completed Bezier curve as well.</h3>
					 <p>
						TODO:
					 </p>
				<h3>Show a screenshot of a slightly different Bezier curve by moving the original control points around and 
					modifying the parameter t via mouse scrolling.</h3>
					<p>
						TODO:
					</p>
			<h2>Section 1 Part 2:</h2>
				<h3>Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to 
					evaluate Bezier surfaces.</h3>
					<p>
						The de Casteljau algorithm extends to Bezier surfaces very easily because we just need to deal with an extra
						dimension (Bezier surfaces are defined by 2D control points array). Given an nxn grid of control points, we 
						first ran the de Casteljau algorithm row-wise, in order to create a 1D N-length array of control points Pi.
						Finally, we ran the de Casteljau algorithm one more time (visualized vertically) on these Pi values to 
						evaluate the Bezier surface.
					</p>
					<p>
						<img src="./teapot.png" alt="Section 1 Part 2 screenshot" width="800" height="600">
					</p>
			<h2>Section 2 Part 3:</h2>
				<h3>Briefly explain how you implemented the area-weighted vertex normals.</h3>
					<p>
						In order to implement the area-weighted vertex normals, we first referenced Lecture 6 slides on shading triangle
						meshes and the Blinn-Phong Reflection model. We knew that for each vertex, the shade would be an area-weighted vertex
						normal of the surrounding faces. Thus, we also referenced the Half-edge data structure from Discussion 4, specifically
						the exercise of traversing the mesh using the half edges. For each surrounding face of the vertex, we stored its area
						as well as its normal vector. Then, we calculated the area-weighted normals, and averaged those to return the final
						unit normal for that vertex.
					</p>
				<h3>Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. 
					Use Q to toggle default flat shading and Phong shading.</h3>
					<p>
						With vertex normals:
						<img src="./teapot part 3 phong shading.png" alt="Section 2 Part 3 screenshot" width="800" height="600">

						Without vertex normals:
						<img src="./teapot part 3 flat shading.png shading.png" alt="Section 2 Part 3 screenshot" width="800" height="600">
					</p>
			<h2>Section 2 Part 4:</h2>
				<h3>Briefly explain how you implemented the edge flip operation and describe any interesting implementation /
					 debugging tricks you have used.</h3>
					 <p>
						TODO:
					 </p>
				<h3>Show screenshots of the teapot before and after some edge flips.</h3>
					 <p>
						Before edge flip:
						<img src="./teapot regular.png" alt="Section 2 Part 4 screenshot 1" width="800" height="600">

						After edge flip:
						<img src="./teapot flip.png" alt="Section 2 Part 4 screenshot 2" width="800" height="600">
					 </p>
				<h3>Write about your eventful debugging journey, if you have experienced one.</h3>
					 <p>
						We used the <b>check_for(...)</b> debugging function to check what elements are getting pointed. We also used
						many print statements line-by-line to check for what specific lines were segfaultin.
					 </p>
			<h2>Section 2 Part 5:</h2>
				<h3>Briefly explain how you implemented the edge split operation and describe any interesting implementation / 
					debugging tricks you have used.</h3>
					<p>
						TODO:
					</p>
				<h3>Show screenshots of a mesh before and after some edge splits.</h3>
					<p>
						Before edge split:
						<img src="./teapot regular.png" alt="Section 2 Part 5 screenshot 1" width="800" height="600">

						After edge split:
						<img src="./teapot split.png" alt="Section 2 Part 5 screenshot 2" width="800" height="600">
					</p>
				<h3>Show screenshots of a mesh before and after a combination of both edge splits and edge flips.</h3>
					<p>
						Before edge splits and flips:
						<img src="./teapot regular.png" alt="Section 2 Part 5 screenshot 3" width="800" height="600">

						Afted edge splits and flips:
						<img src="./teapot splits and flips.png" alt="Section 2 Part 5 screenshot 3" width="800" height="600">
					</p>
				<h3>Write about your eventful debugging journey, if you have experienced one.</h3>
					<p>
						We used the <b>check_for(...)</b> debugging function to check what elements are getting pointed. We also used
						many print statements line-by-line to check for what specific lines were segfaultin.
					</p>
				<h3>If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on 
					boundary edges.</h3>
					<p>
						TODO:
					</p>
			<h2>Section 2 Part 6:</h2>
				<h3>Briefly explain how you implemented the loop subdivision and describe any interesting implementation / 
					debugging tricks you have used.</h3>
					<p>
						TODO:
					</p>
				<h3>Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. 
					What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?</h3>
					<p>
						TODO:
					</p>
				<h3>Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube 
					becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips
					 and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. 
					 Also explain how your pre-processing helps alleviate the effects.</h3>
					<p>
						TODO:
					</p>
				</h3>If you have implemented any extra credit extensions, explain what you did and document how they work with 
				screenshots.</h3>
					<p>
						TODO:
					</p>
	</body>
</html>